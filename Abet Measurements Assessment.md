<h1>Abet Measurements Assesment</h1>
<h2>Team Alpha: Virginia Pettit, Isaak Ramirez, Kevin Shurtz</h2>

<h3>This document asseses how our team met the Abet Measurements as listed on the end of the SE course scheduale.</h3> 

<p><h3>3b:</h3><b>Ability to analyze a problem, and identify and define the computing requirements appropriate to its solution
Analysis: executive summary, context, systems constraints, user constraints
Computing requirements: operating system, network connectivity, file system, user interface, security, deployment</b></p>

<p>Our team has analyzed the problem given to us to solve: the need for a course moving tool. Some of the problem and requirements were given to us, but we had to identify and define some of the computing requjirements on our own. We spent quite a bit of time figuring out what tools we should use and what architecture we should employ for this project. We eventually decided that we would use SQLite in addition to the prescribed Java.</p><p> As far as analysis, we have worked to make our system work with user constraints - for this we have a useful help functionality and a read me in common english, as well as a glossary, since it is likely this system will be used by someone who is not the most familiar with software and software development. We also identified and limited our project's scope to that of a University teacher or administrator. We also worked quite a bit on customer requirements. We started the project by asking in depth question of our "client" and wrote us some possible user stories.</p><p>Computing requirements were also something we concidered. We have options in our program for Windows, Mac, and Linux operating systems. We are not worried about security being an issue as the people who will be using the system will be inputing information they already have and our system will not give them any new data, it just figures things out from the input data. The file system and deployment system are nice and encapsulated within our system, so the user will not have to worry about that. We also made a straightforward user interface via the command line. We have help commands and have made the commands as simple and few as possible</p>

<p><h3>3d:</h3><b>Ability to function effectively on teams to accomplish a goal
Individual contribution
Planning / Leadership</b></p>

<p>As well as technical programming skills, this project has taught the three of us a lot about teamwork in the the bounds of software development. Because it is a fairly well defined assignment, we all started out with very simmilar goal and since then we have been working as a team to that goal. As per the agile model, we have all been working to fill all the positions needed on the team. We've made great contributions individually, but we've made the most impressive progress through teamwork and collaboration. We've spent time planning out the architecture of the software system, but we've also spent time planning out group goals, time constraints, meetings, and our own strengths and weaknesses. The three of us have not found the need to appoint someone as a leader since there are only three of us and our skill sets all overlap.</p>

<p><h3>3e:</h3><b>An understanding of professional, ethical, legal, security and social issues and responsibilities</b></p>

<p>Software Engineering has also taught out team a lot about issues and responsibilities in the software development world. The weekly demos of Cucumber tests have brought up some times when it would be easy to manipulate the "client" into thinking that we had done more than we actually had, but we talked about how that would be unprofessional and unethical. We've also learned that if we're going to be software developers we will have lots of responsibilites and if we get to be lead programmers, we will have the ability to make choices that will require ethical and social dileberation. Fortunately, there weren't many dillemas that popped up on this course move project. We didn't really have to address ethical or social problems.</p>

<p><h3>3k:</h3><b>Ability to apply design and development principles in the construction of software systems of varying complexity
Design process: UML, Data Modeling
Development Process: versions, testing, assertions, documentation</b></p>

<p>Our team has grown a lot in our ability to apply design and deelopment principles to the creation of our software projects. We did use quite a few visual representations of our system architecture, but we did not use official UML or a data modeling software. WE also drew out the schemas for our database, but in a bit of a rough way. We had a lot of data to model based on all the intricacies of the project domain (students, professors, classes, sections, class times, etc.)</p><p>As far as the development process, it was difficult for our team to model the professional project because all of us are taking multiple classes and cannot spent the average 40 hour work week on this project. This made the changes between iterations of the project be small. Based on the rapid due date of the project, we were also unable to have multiple working versions being tested. We started with a tiny bit our our system done during the first check in day, and then added a little bit each week. As per the Agile method, we made sure that the project we presented worked 100% each week. That also made it hard to make big jumps of progress. As prescribed, we used Cucumber testing to show our progress. We learned that not all projects are suited to the test first method, and we do not think this project is one that is suited to TDD.</p><p>To make our system easy to use and update we have a simle readme to explain use. We also documented our code with occasional comments and in some places with Javadocs, which is an industry standard. All of this should make this project easy to maintain, refactor, or extend.</p>
